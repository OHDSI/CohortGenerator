---
title: "Advanced Cohort Subsets Tutorial"
author: "Freddy A. Cruz and James Gilbert"
highlight-style: github
editor: 
  markdown: 
    wrap: 72
output:
  html_document:
    number_sections: yes
    toc: yes
  pdf_document:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Advanced Cohort Subset Creation Tutorial}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE,warning=FALSE}
old <- options(width = 80)
knitr::opts_chunk$set(
  cache = FALSE,
  comment = "#>",
  error = FALSE
)
someFolder <- tempdir()
packageRoot <- tempdir()
```

# Introduction

Cohort subsets can be complex definitions of 'meta-cohorts', derived
from a larger cohort. These subsets are defined by applying additional
inclusion or exclusion criteria to the original group, creating a more
targeted population for analysis. This guide attempts to use more
advanced windowing functions to capture definitions of populations that
are often impossible or extremely challenging with conventional Circe
definitions. It is important to note that, for the vast majority of
cohort definitions the use of subset populations is often uneccessary,
and using the Atlas designer or `{Capr}` package are preffered.

**NOTE**: Please review **CreatingCohortSubsetDefinitions** vignette
before reviewing this vignette.

## Required Package

Before going any further, ensure you are using the developer branch of
Cohort Generator:

```{r setup = FALSE, eval=FALSE, warning=FALSE}
install.packages("remotes")
remotes::install_github("OHDSI/CohortGenerator", ref='develop')
```

## Cohort Definition Set

As mentioned in the Creating Cohort Subset Definitions, the very basics
of subsetting all starts with a cohort definition set - a structured
collection of cohort definitions. For future reference, our example
cohort definition set will be:

```{r}
jsonFilePath <- system.file("testdata", "CohortsToSubset.JSON", package = "CohortGenerator")
cohortDefinitionSet <- jsonlite::fromJSON(jsonFilePath)

cohortDefinitionSet |> 
  dplyr::select("cohortId", "cohortName") |> 
  knitr::kable()
```

## Terminology

-   **Target cohort** in all examples the target cohort is the cohort
    for which you are creating a subset population off of for example
    `patients exposed to Celecoxib.` In this case, celcoxib is the
    target and whatever cohort being subsetted is the indication.
-   **Subset cohorts** these are cohorts that are the result of applying
    a subset definition to target cohort. For example
    `patients exposed to Celecoxib with no prior history of GI Bleeding`
-   **Operator cohorts** these are cohorts that are used in calls to
    `createCohortSubset` to modify target cohorts. The operator cohort
    filters patients based on the presence (or absence) of specific
    events within defined time windows, without modifying the target
    cohort's index date. It serves solely to include or exclude patients
    when creating the subset cohort. In the above example of a subset
    cohort, the operator cohort is `GI Bleeding` as patients in the
    specified time window (all time before Celecoxib exposure) are
    excluded from the resulting subset cohort if they are inside the
    `GI bleeding` cohort.
-   **Subet definitions** subset definitions are abstract `R` objects
    that can be applied to an arbitrary number of cohorts. For example
    in the above, the subset definition would be
    `no prior history of GI Bleeding`. We could then apply this to a
    cohort definition set containing dozens of RxNorm ingredients.

# Subsetting Logic

Before we begin introducing subset logic/examples, it is important to
understand the window function

```{r, eval=FALSE}
CohortGenerator::createSubsetCohortWindow(
  startDay,
  endDay,
  targetAnchor,
  subsetAnchor = NULL,
  negate = FALSE
)
```

-   The start day is just the start day for the time window.

-   The end day is the end day for the time window.

-   The target anchor has two parameters:

    -   cohortStart

        -   When the target cohort starts

    -   cohortEnd

        -   when the target cohort ends

-   The subset anchor also has two parameters, but its default is
    cohortStart

    -   cohortStart

        -   When the subset cohort starts

    -   cohortEnd

        -   When the subset cohort ends

-   Negate

    -   Simply an inclusion or exclusion to a time window. This means
        that if we set the negate to true, we want the opposite of the
        declared time window and if we set it to false, we want all the
        results that do satisfy the time window.

Throughout these examples, we intend to display various subsetting
scenarios that often times, using Cohort Generator would be the only
feasible package to use to create the subset of interest rather than
using Circe.

Some of the keypoints to capture is subsetting to a target in several
events: before the targets start date, during the targets event, and
after the targets end date.

## Before Target Window

Let's start off simple, by capturing patients who have GI Bleed and
choosing celcoxib as our target cohort. However, we want to narrow it
down to a specific time window. We want to capture all subjects who have
a GI Bleed occur before their celcoxib exposure. To do this, we have to
use negative numbers as a way to say: LOOK BEFORE X, and in this case, X
means celcoxib start date as indicated by the target anchor.

```{r echo = TRUE, results = 'hide', warning = FALSE, message = FALSE}
library(CohortGenerator)

priorGiBleeds <- CohortGenerator::createCohortSubsetDefinition(
  name = "w",
  definitionId = 1,
  subsetOperators = list(
    CohortGenerator::createCohortSubset(
      name = " prior history of GI Bleed",
      cohortIds = c(3),  # GI Bleed cohort ID
      cohortCombinationOperator = "any",
      negate = FALSE, 
      # Define the window condition
      windows = list(
        CohortGenerator::createSubsetCohortWindow(
          startDay = -9999,  # Look far back into the past
          endDay = -1,       # Only up to the day BEFORE the index cohort starts
          targetAnchor = "cohortStart",
          subsetAnchor = "cohortStart"
        )
      )
    )
  )
)
```

We can then apply this subset definition to to the cohort definition
set; resulting in a new **subset cohort**.

```{r}
cohortDefinitionSet <- cohortDefinitionSet |>
  addCohortSubsetDefinition(priorGiBleeds, targetCohortIds = c(1))

cohortDefinitionSet |> 
  dplyr::select("cohortId", "cohortName", "subsetParent", "isSubset") |> 
  knitr::kable()
```

## During target window functions

Prior history (or not) of a disease is a relatively striaghtforward
concept to capture with conventional Circe definitions. A more complex
form of window logic is the notion of a cohort that only happens
*during* a time window. For example, if you want to find patients who
have a GI bleed while exposed or unexposed to a medication. This logic
is complicated because an individual can enter and exit the drug
exposure many times.

One common window function may be to define a subset of our target
population such that events of the operator cohort occur only during our
exposed time. For this example, we can create a series window function
using the `subsetAnchor` parameter such as this:

```{r}
withinTargetWindows <- list(
  # Condition 1: GI Bleed Start Date After or Equal to Target Cohort Start
  CohortGenerator::createSubsetCohortWindow(
    startDay = 0, 
    endDay = 99999, 
    targetAnchor = "cohortStart", 
    subsetAnchor = "cohortStart"
  ),
  
  # Condition 2: GI Bleed end Date On or Before Target Cohort End
  CohortGenerator::createSubsetCohortWindow(
    startDay = -99999, 
    endDay = 0, 
    targetAnchor = "cohortEnd", 
    subsetAnchor = "cohortStart"
  )
)
```

This would read as:

```         
The object cohort must START on or after the target cohort's index
                            
AND
                            
The object cohort must START on or before the target cohort's end
```

Note, that without the second window rule, the event could happen any
time after the exposure starts, even if the individual were no longer
exposed to celcoxib.

We can then apply this windowing logic inside a second subset definition

```{r}
withGiBleedDuringExplosure <- CohortGenerator::createCohortSubsetDefinition(
  name = "requring event of ",
  definitionId = 2,
  subsetOperators = list(
    # here we are saying 'subset to only those patients in cohort 2'
    CohortGenerator::createCohortSubset(
      name = "GI Bleed during cohort",
      # Note that this can be set to any id - if the
      # cohort is empty or doesn't exist this will not error
      cohortIds = c(3), # Operator cohort ID(Gi bleed)
      cohortCombinationOperator = "any", # Only applies if you use multiple operator cohorts
      negate = FALSE,
      windows = withinTargetWindows
    )
  )
)

cohortDefinitionSet <- cohortDefinitionSet |>
  addCohortSubsetDefinition(withGiBleedDuringExplosure, targetCohortIds = c(1))

# View both subset cohorts
cohortDefinitionSet |>
  dplyr::select("cohortId", "cohortName", "subsetParent", "isSubset") |> 
  knitr::kable()

```

In this case, we subsetted GI bleed to celcoxib.

Note: any number of window operators can be applied with chains of `AND`
logic.

The above logic can be vieried in sql form:

```{r eval=FALSE}
cohortDefinitionSet |> 
  dplyr::filter(subsetDefinitionId == 2) |> 
  dplyr::pull("sql") |> 
  writeLines()
```

```{sql eval = FALSE}
DELETE FROM @cohort_database_schema.@cohort_table WHERE cohort_definition_id = 1002;
DROP TABLE IF EXISTS #cohort_sub_base;
SELECT * INTO #cohort_sub_base FROM @cohort_database_schema.@cohort_table
WHERE cohort_definition_id = 1;
DROP TABLE IF EXISTS #S_1;
 SELECT
  A.subject_id, 
  A.cohort_start_date, 
  A.cohort_end_date
INTO #S_1
FROM (
  SELECT
    T.subject_id, 
    T.cohort_start_date, 
    T.cohort_end_date
  FROM #cohort_sub_base T
  JOIN @cohort_database_schema.@cohort_table S ON T.subject_id = S.subject_id
  WHERE S.cohort_definition_id in (2)
  -- AND Cohort lies within window criteria
   AND (S.cohort_start_date >= DATEADD(d, 0, T.cohort_start_date) AND S.cohort_start_date <= DATEADD(d, 99999, T.cohort_start_date))
   AND (S.cohort_start_date >= DATEADD(d, 0, T.cohort_end_date) AND S.cohort_start_date <= DATEADD(d, 0, T.cohort_end_date))
  GROUP BY T.subject_id, T.cohort_start_date, T.cohort_end_date
  HAVING COUNT (DISTINCT S.COHORT_DEFINITION_ID) >= 1
) A

;
INSERT INTO @cohort_database_schema.@cohort_table
SELECT
    1002 as cohort_definition_id,
    T.subject_id,
    T.cohort_start_date,
    T.cohort_end_date
FROM #S_1 T;

DROP TABLE IF EXISTS #cohort_sub_base;
DROP TABLE IF EXISTS #S_1;
```

Note that in this case, an individual may have multiple `celcoxib`
exposure windows but only the windows that have a GI bleed would be
included in a subset cohort.

## Object era during target era windows

In the previous example, we were only concerned with acute events during
some exposure window. This would not capture a more complex case, for
example, where individuals are exposed a second medication (such as
ibuprofen) during their celcoxib exposure, that terminates during their
celocxib exposure (i.e. they do not remain exposed to ibuprofen).

In this example we would seek to define a slightly different window
function to the one above:

1.  The target and subset anchors are modified so the subset end date
    happen before OR on the target's end date. Therefore, celcoxib and
    ibuprofen exposure align with each other as ibuprofen must end
    before or during the target's end date.

```{r}
strictlyWithinTargetWindows <- list(
  CohortGenerator::createSubsetCohortWindow(
    startDay = 0, 
    endDay = 99999,
    targetAnchor = "cohortStart", 
    subsetAnchor = "cohortStart"
  ),
  CohortGenerator::createSubsetCohortWindow(
    startDay = -99999,  # Look backward from Celecoxib's end date
    endDay = 0,  # Ibuprofen must finish ON or BEFORE Celecoxib ends
    targetAnchor = "cohortEnd",  # Reference Celecoxib's end date
    subsetAnchor = "cohortEnd"  # Compare to Ibuprofen's end date
  )
)

ibuprofenDuring <- createCohortSubsetDefinition(
  name = "requring exposure of",
  definitionId = 3,
  subsetOperators = list(
    createCohortSubset(
      name = "Iburpofen strictly during target",
      # Note that this can be set to any id - if the
      # cohort is empty or doesn't exist this will not error
      cohortIds = 2, # Operator cohort ID
      cohortCombinationOperator = "any", # Only applies if you use multiple operator cohorts
      negate = FALSE,
      windows = strictlyWithinTargetWindows
    )
  )
)

cohortDefinitionSet <- cohortDefinitionSet |>
  addCohortSubsetDefinition(ibuprofenDuring, targetCohortIds = c(1))

# View both subset cohorts
cohortDefinitionSet |>
  dplyr::filter(subsetDefinitionId == 3) |>
  dplyr::select("cohortId", "cohortName", "subsetParent", "isSubset") |> 
  knitr::kable()
```

## Object era after target era window

In the last scenario, we focus on patients exposed to ibuprofen strictly
within 1 to 365 days after their celcoxib exposure end date. This means
any ibuprofen exposure that starts before the specified time window
(celcoxib exposure end date) are to be excluded from the subset. Any
ibuprofen exposure that starts within 1 to 365 days after celcoxib
exposure end date are to be included in the subset.

```{r}
strictlyAfterTargetWindows <- list(
  #Operator must start strictly after the target's end date
  CohortGenerator::createSubsetCohortWindow(
    startDay = 1,
    endDay = 365,
    targetAnchor = "cohortEnd",
    subsetAnchor = "cohortStart"
  )
)

ibuprofenStrictlyAfter <- CohortGenerator::createCohortSubsetDefinition(
  name = "requiring",
  definitionId = 5,
  subsetOperators = list(
    CohortGenerator::createLimitSubset(name = "first exposure", limitTo = "firstEver"),
    CohortGenerator::createCohortSubset(
      name = "w iburpofen strictly after target",
      cohortIds = 2,
      cohortCombinationOperator = "any",
      negate = FALSE,
      windows = strictlyAfterTargetWindows
    )
  )
)

cohortDefinitionSet <- cohortDefinitionSet |>
  CohortGenerator::addCohortSubsetDefinition(ibuprofenStrictlyAfter, targetCohortIds = c(1))

cohortDefinitionSet |>
  dplyr::filter(subsetDefinitionId == 5) |>
  dplyr::select("cohortId", "cohortName", "subsetParent", "isSubset") |> 
  knitr::kable()
```

### Using Negate Parameter in Window

Let's say I have a scenario where I wanted to subset ibuprofen to
celcoxib after celcoxib end date. In this scenario, we want to analyze
patients who strictly started taking ibuprofen a quarter year after
their celcoxib exposure. To do this, we want to make sure we
specifically EXCLUDE any ibuprofen that occurs before 91 days. One
simple way to do this is using the negate parameter in the window
function:

```{r}
ibuprofenExclude <- 
  CohortGenerator::createSubsetCohortWindow(
    startDay = 1,
    endDay = 90,
    targetAnchor = "cohortEnd",
    subsetAnchor = "cohortStart",
    negate = TRUE
  )

ibuprofenInclude <-  CohortGenerator::createSubsetCohortWindow(
    startDay = 91,
    endDay = 365,
    targetAnchor = "cohortEnd",
    subsetAnchor = "cohortStart",
    negate = FALSE
  )

ibuprofenQuarterAYearAfter <- CohortGenerator::createCohortSubsetDefinition(
  name = "requiring",
  definitionId = 6, # New identifier for this subset
  subsetOperators = list(
    CohortGenerator::createCohortSubset(
      name = "w ibuprofen after a quarter of a year",
      cohortIds = c(2), # Subset ibuprofen exposures (cohort_definition_id=2)
      cohortCombinationOperator = "any",
      negate = FALSE,
      windows = list(ibuprofenExclude, ibuprofenInclude) # Use the defined windows
    )
  )
)

cohortDefinitionSet <- cohortDefinitionSet |>
  CohortGenerator::addCohortSubsetDefinition(ibuprofenQuarterAYearAfter, targetCohortIds = c(1))

cohortDefinitionSet |>
  dplyr::filter(subsetDefinitionId == 6) |>
  dplyr::select("cohortId", "cohortName", "subsetParent", "isSubset") |> 
  knitr::kable()
```

By using the negate paremeter, we make sure that the following logic
exists:

---
EXCLUDE ANY EXPOSURE THAT OCCURS 1 to 90 DAYS AFTER CELCOXIB END DATE
AND
INCLUDE ANY EXPOSURE THAT OCCURS 91 TO 365 DAYS AFTER CELCOXIB END DATE
---

\

# Setting up Packages for Testing

Similar to CreatingCohortSubsetDefinitions vignette, we will construct a
dummy OMOP data model to demonstrate and visualize the application of
using Cohort Generator to create subsets using advanced windowing logic.
To continue, please ensure duckdb is installed.

```{r setup = FALSE, eval=FALSE, warning=FALSE}
install.packages("duckdb")
```

# Testing Data / Subsets

```{r, echo = TRUE, warning = FALSE, message = FALSE, error = FALSE}
databaseFile <- tempfile(fileext = ".duckdb")
duckdbConnectionDetails <- DatabaseConnector::createConnectionDetails(
  dbms = "duckdb",
  server = databaseFile
)
resultsSchema <- "main"
connection <- DatabaseConnector::connect(duckdbConnectionDetails)

data("omopCdmPerson", package = "CohortGenerator")
DatabaseConnector::insertTable(
  connection = connection,
  databaseSchema = resultsSchema,
  tableName = "person",
  data = omopCdmPerson
)

data("omopCdmDrugExposure", package = "CohortGenerator")
DatabaseConnector::insertTable(
  connection = connection,
  databaseSchema = resultsSchema,
  tableName = "drug_exposure",
  data = omopCdmDrugExposure
)

data("omopCdmGIBleed",package = "CohortGenerator")
DatabaseConnector::insertTable(
  connection = connection,
  databaseSchema = resultsSchema,
  tableName = "gi_bleed",
  data = omopCdmGIBleed
)
```

# Generating Subsets

```{r, echo = TRUE, warning = FALSE, message = FALSE, error = FALSE,results= 'hide'}
cohortTableNames <- CohortGenerator::getCohortTableNames()
CohortGenerator::createCohortTables(
  connection = connection,
  cohortDatabaseSchema = "main",
  cohortTableNames = cohortTableNames
)
# ### As subsets are a big side effect we need to be clear what was generated and have good naming conventions

CohortGenerator::generateCohortSet(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTableNames = CohortGenerator::getCohortTableNames(),
  cohortDefinitionSet = cohortDefinitionSet
)

```

# Output of Dummy Test Data

```{r, echo = TRUE, warning = FALSE, message = FALSE, error = FALSE, results = 'hide', fig.width = 14, fig.height = 10, fig.align = 'center'}
library(dplyr)
library(ggplot2)
cohorts <- DatabaseConnector::querySql(
  connection = connection,
  sql = "
    SELECT c.*, p.gender_concept_id, YEAR(c.cohort_start_date) - p.year_of_birth AS age
    FROM main.cohort c
    INNER JOIN main.person p ON c.subject_id = p.person_id
    ORDER BY c.COHORT_DEFINITION_ID, c.SUBJECT_ID, c.COHORT_START_DATE;"
)
names(cohorts) <- tolower(names(cohorts))
cohort_data <- cohorts %>%
  inner_join(cohortDefinitionSet[,c("cohortId", "cohortName")], by = c("cohort_definition_id" = "cohortId")) %>%
  mutate(cohort_legend = paste(cohort_definition_id, "-", cohortName)) %>%
  mutate(gender = ifelse(gender_concept_id == 8532, "Female", "Male"), 
         facet_label = paste("Subject:", subject_id, "- Gender:", gender)) 

# Order factor levels for facets by subject_id
cohort_data$facet_label <- factor(cohort_data$facet_label, 
                                  levels = unique(cohort_data$facet_label[order(cohort_data$subject_id)]))

# Order factor levels for legend by cohort_definition_id
cohort_data$cohort_legend <- factor(cohort_data$cohort_legend, 
                                    levels = unique(cohort_data$cohort_legend[order(cohort_data$cohort_definition_id)]))

# Create the plot with annotations for age when cohort_definition_id == 1
ggplot(cohort_data, aes(x = cohort_start_date, xend = cohort_end_date, 
                        y = as.factor(cohort_definition_id), 
                        group = interaction(cohort_definition_id, subject_id), 
                        color = cohort_legend)) +
  geom_segment(aes(xend = cohort_end_date, yend = as.factor(cohort_definition_id)), size = 2) +
  geom_point(aes(x = cohort_start_date, y = as.factor(cohort_definition_id)), size = 4, shape = 21, fill = "black") +
  geom_text(data = cohort_data[cohort_data$cohort_definition_id == 1, ], 
            aes(label = age, 
                x = as.Date((as.numeric(cohort_start_date) + as.numeric(cohort_end_date)) / 2, origin = "1970-01-01"), 
                y = as.factor(cohort_definition_id)), 
            vjust = -0.5, size = 4, color = "black") +
  labs(title = "Cohort Duration by Cohort Definition ID Faceted by Subject ID and Gender",
       x = "Date",
       y = "Cohort Definition ID",
       color = "Cohort Definition") +  
  scale_x_date(limits = as.Date(c("2002-01-01", "2004-06-31")), date_breaks = "1 year", date_labels = "%Y") +
  scale_color_brewer(palette = "Paired") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    strip.text.x = element_text(size = 8),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  ) +
  facet_wrap(~ facet_label, ncol = 3) 
```

In the visualization, there are at total of 12 subjects, all exposed to
celcoxib within the same set of time. However, there are some subjects
who have been exposed to ibuprofen while there are others who have been
exposed to GI Bleed. Celcoxib, ibuprofen and GI bleed are the main
cohorts, while the rest of the subsets are derived off of the main
cohorts. In total, there are 5 subsets that all have celcoxib as the
target cohort.

As an example, lets analyze cohort id 1001: "**Celcoxib w prior history
of GI Bleed**". Note that the only subject that qualifies to this subset
is subject 12, because they do have a GI Bleed event that occurs before
Celcoxib. Any event that happens during or after celcoxib are not taken
into consideration for this subset. The same logic applies to the other
subjects. The subset only applies to the subject if their main cohort
events took place as the intended subset window logic design to
captures.

Therefore, it explains why some subjects have very few subsets, while
other subjects qualify for just about every subset.

# Conclusion

In this tutorial we have demonstrated how to use different windowing
functions with the `CohortGenerator` subsetting functionality.
