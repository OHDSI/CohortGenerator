---
title: "Creating Cohort Subset Definitions"
author: "James P. Gilbert, Anthony G. Sena and Freddy Avila Cruz"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    toc: yes
  pdf_document:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Creating Cohort Subset Definitions}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
old <- options(width = 80)
knitr::opts_chunk$set(
  cache = FALSE,
  comment = "#>",
  error = FALSE
)
someFolder <- tempdir()
packageRoot <- tempdir()
library(CohortGenerator)
```

# Introduction

This guide aims to describe the process of cohort subsetting using `CohortGenerator`.
The purpose of Cohort subsetting operations is to refine or filter cohorts by applying standardized rules like limiting to certain events, specific time windows, combination of cohorts, etc.
As a result, new cohorts are generated to assist in specific analytics or study requirements.
To effictively demonstrate the process of Cohort Subsetting, a dummy OMOP data model will be used for testing.

# Required Package

DuckDB is required to further demonstrate the use case of Cohort Generator for this specific vignette.

```{r}
install.packages("duckdb")
```

# Testing Data

The purpose of this test data is to demonstrate how Cohort Generator is applied by using it's functionality to create subsets based on existing cohorts.
We will begin by creating a dummy OMOP data model and populating the dummy OMOP data model with subjects and drug exposure.
The drug exposure itself will be recognized as ibuprofen exposure.
The sample data itself is found in SaveVignetteCohortToDuckDB.R found in inst/testdata folder if interested in analyzing it.

```{r, echo = TRUE, warning = FALSE, message = FALSE, error = FALSE}
databaseFile <- tempfile(fileext = ".duckdb")
duckdbConnectionDetails <- DatabaseConnector::createConnectionDetails(
  dbms = "duckdb",
  server = databaseFile
)
resultsSchema <- "main"
connection <- DatabaseConnector::connect(duckdbConnectionDetails)

person_data_path <- system.file("testdata", "person_data.RData", package = "CohortGenerator")
load(person_data_path)

drug_exposure_data_path <- system.file("testdata", "drug_exposure_data.RData", package = "CohortGenerator")
load(drug_exposure_data_path)

DatabaseConnector::insertTable(
  connection = connection,
  databaseSchema = resultsSchema,
  tableName = "person",
  data = person_data
)
# Insert updated data into the 'drug_exposure' table
DatabaseConnector::insertTable(
  connection = connection,
  databaseSchema = resultsSchema,
  tableName = "drug_exposure",
  data = drug_exposure_data
)
```

After creating the dummy OMOP data model, we will look into the subsetting function of Cohort Generator.

# Subset definitions

Subset definitions are named sets of operations that can be applied to a set of one or more cohorts.
The current operations that you can apply to cohorts are:

-   Demographic subsets
-   Limit subsets
-   Cohort subsetting

Operations can be sequentially chained within *subset definitions* and all outputs are considered full cohorts that can be passed into to other packages as if they are cohorts designed in packages.

## Demographic subset operations

This subsetting process allows you to capture the age, race/ethnicity gender within a cohort as subgroups.
For example, "subset cohorts to subjects that are between the ages 20 and 50 years old".

```{r}

ageCriteria <- CohortGenerator::createDemographicSubset(
  ageMin = 20,
  ageMax = 50
)

```

## Subsetting to other cohorts

This type of operation allows you to subset a cohort to only those subjects included in one or more other cohorts, ensuring the results focus on a shared or overlapping population.
The basic of creating a subset is given.
To learn more about subset windowing, review Advanced Cohort Subset Tutorial vignette.

As an example, to identify subjects exposed to celcoxib who also had an exposure to ibuprofen within any time, the subset would be defined as:

```{r}
ibuprofenSubset <- CohortGenerator::createCohortSubset(
  name = "ibuprofen exposure",
  cohortIds = 2,  # Ibuprofen cohort
  cohortCombinationOperator = "any",  # Look for any Ibuprofen exposure
  negate = FALSE,  # We want to include (not exclude) participants exposed to Ibuprofen,
  windows = list(
    CohortGenerator::createSubsetCohortWindow(
        startDay = -99999,
        endDay = 99999,
        targetAnchor = "cohortStart",
        subsetAnchor = "cohortStart"
    ),
    CohortGenerator::createSubsetCohortWindow(
      startDay = -99999,
      endDay = 99999,
      targetAnchor = "cohortStart",
      subsetAnchor = "cohortEnd"
    )
  )
)
```

In this subset, we use **cohortId = 2** to extract all the subjects exposed to ibuprofen.
After that, we set the **combinationOperation = all**, meaning we are looking for exposure in both cohorts.
We then set the **negate = false** to include all subjects.
After that, we define our window, meaning that we define the time of interest we want to look for subjects with celcoxib exposed to ibuprofen.
In this case, we look for all possible time window of a subjects exposed to ibuprofen with celcoxib.

## Limit Subset

Limit subsets are designed to apply restrictions or filters to cohorts/subsets based on limit criteria.
There are several ways we can do this through the various parameters provided.
As an example, we will create a limit subset that is focused on extracting the LAST ibuprofen exposure of a patient.

```{r}

ibuprofenLimitSubset <- CohortGenerator::createLimitSubset(
  name = "Last Ibuprofen Exposure",
  priorTime = 0,  
  followUpTime = 0,  
  limitTo = "lastEver",  # Only the first Ibuprofen exposure per patient
  calendarStartDate = as.Date("2000-01-01"),  # Start date of observation period
  calendarEndDate = as.Date("2008-12-31")  # End date of observation period
)

```

In the subset above, there is no observation period required.
The most important part is setting the limitTo parameter to lastEver, such that we can capture the last event in the patient's history.
If we wanted to know the first event in the patient's history, we would then set **limitTo = firstEver**.
If we also wanted the first event after applying a prior time, we would set**limitTo = earliestRemaining**.
The last option we have is if we wanted the last event within the observation window after applying a follow up time, we would have to set **limitTo = latestRemaining**.

# Combining all the Subsets

After creating all the necessary subsets to target patients exposed to ibuprofen and celcoxib, combining them is necessary to produce the filtered subjects of interest.

```{r}

ibuprofenWCelcoxib <- CohortGenerator::createCohortSubsetDefinition(
  name = "Celecoxib and Ibuprofen Exposures",
  definitionId = 11,  # Unique ID for this subset
  subsetOperators = list(
    ageCriteria,
    ibuprofenSubset,
    ibuprofenLimitSubset
  ),
  subsetCohortNameTemplate = "Celcoxib with Ibuprofen Exposure - Last Exposure for Subject Aged 20 - 50"
)

```

# Creating cohort subset definitions

Down below, we are extracting sampled cohorts that mimic what the actual cohort would be like, produced by a script called SaveVignetteCohortToDuckDB.R found in inst/testdata folder.
After extracting those cohorts from the csv file(celcoxib and ibuprofen), we can finally reference the ibuprofen subset to celcoxib by setting the target id to the cohort id of celcoxib.
That directly translates to ibuprofen subsetting off of celcoxib.

```{r}
jsonFilePath <- system.file("testdata", "CohortsToSubset.JSON", package = "CohortGenerator")
cohortDefinitionSet <- jsonlite::fromJSON(jsonFilePath)

cohortDefinitionSet <- cohortDefinitionSet |>
  CohortGenerator::addCohortSubsetDefinition(ibuprofenWCelcoxib,targetCohortIds = c(1))
cohortDefinitionSet |> 
  dplyr::select("cohortId", "cohortName") |> 
  knitr::kable()

```

# Generating subsets

Executing CohortGenerator, we can now include the subset operations when our cohorts are generated:

```{r, echo = TRUE, warning = FALSE, message = FALSE, error = FALSE,results= 'hide'}
cohortTableNames <- CohortGenerator::getCohortTableNames()
CohortGenerator::createCohortTables(
  connection = connection,
  cohortDatabaseSchema = "main",
  cohortTableNames = cohortTableNames
)
# ### As subsets are a big side effect we need to be clear what was generated and have good naming conventions

CohortGenerator::generateCohortSet(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTableNames = CohortGenerator::getCohortTableNames(),
  cohortDefinitionSet = cohortDefinitionSet
)


```

Cohort subset definitions can be run incrementally.
In fact, if the base cohort definition changes for any reason, any subsets will automatically be re-executed when calling `generateCohortSet`.

# Output of Dummy Test Data

In the graph below, there are 12 subjects.
Each of these subjects are exposed to celcoxib once while some of these subjects are exposed to ibuprofen, sometimes two ibuprofen exposure.The age of each subjects is also provided.
Based on this information, the subset ibuprofen with celcoxib is generated for a few selected individuals if they met the defined criteria above (celcoxib and ibuprofen, age, and extracting last ibuprofen exposure).

```{r, echo = TRUE, warning = FALSE, message = FALSE, error = FALSE, results = 'hide', fig.width = 10, fig.height = 6}
library(dplyr)
library(ggplot2)
cohorts <- DatabaseConnector::querySql(
  connection = connection,
  sql = "
    SELECT c.*, p.gender_concept_id, YEAR(c.cohort_start_date) - p.year_of_birth AS age
    FROM main.cohort c
    INNER JOIN main.person p ON c.subject_id = p.person_id
    ORDER BY c.COHORT_DEFINITION_ID, c.SUBJECT_ID, c.COHORT_START_DATE;"
)
names(cohorts) <- tolower(names(cohorts))
cohort_data <- cohorts %>%
  inner_join(cohortDefinitionSet[,c("cohortId", "cohortName")], by = c("cohort_definition_id" = "cohortId")) %>%
  mutate(cohort_legend = paste(cohort_definition_id, "-", cohortName)) %>%
  mutate(gender = ifelse(gender_concept_id == 8532, "Female", "Male"), 
         facet_label = paste("Subject:", subject_id, "- Gender:", gender)) 

# Order factor levels for facets by subject_id
cohort_data$facet_label <- factor(cohort_data$facet_label, 
                                  levels = unique(cohort_data$facet_label[order(cohort_data$subject_id)]))

# Order factor levels for legend by cohort_definition_id
cohort_data$cohort_legend <- factor(cohort_data$cohort_legend, 
                                    levels = unique(cohort_data$cohort_legend[order(cohort_data$cohort_definition_id)]))

# Create the plot with annotations for age when cohort_definition_id == 1
ggplot(cohort_data, aes(x = cohort_start_date, xend = cohort_end_date, 
                        y = as.factor(cohort_definition_id), 
                        group = interaction(cohort_definition_id, subject_id), 
                        color = cohort_legend)) +
  geom_segment(aes(xend = cohort_end_date, yend = as.factor(cohort_definition_id)), size = 2) +  # Thicker lines (size = 2)
  geom_point(aes(x = cohort_start_date, y = as.factor(cohort_definition_id)), size = 4, shape = 21, fill = "black") +  # Adding bullet points
  geom_text(data = cohort_data[cohort_data$cohort_definition_id == 1, ], 
            aes(label = age, 
                x = as.Date((as.numeric(cohort_start_date) + as.numeric(cohort_end_date)) / 2, origin = "1970-01-01"),  # Midpoint calculation
                y = as.factor(cohort_definition_id)), 
            vjust = -0.5, size = 4, color = "black") +  # Adding age label in the center
  labs(title = "Cohort Duration by Cohort Definition ID Faceted by Subject ID and Gender",
       x = "Date",
       y = "Cohort Definition ID",
       color = "Cohort Definition") +  
  scale_x_date(limits = as.Date(c("2002-01-01", "2004-06-31")), date_breaks = "1 year", date_labels = "%Y") +  
  scale_color_brewer(palette = "Paired") +  
  theme_minimal() +
  theme(legend.position = "bottom") +  
  facet_wrap(~ facet_label)  # Correct facet wrapping

```

# Saving and loading subset definitions

## Saving to packages/directories

Saving applied subsets can automatically be added to a project using `saveCohortDefinitionSet`

```{r eval=FALSE}
saveCohortDefinitionSet(cohortDefinitionSet,
  subsetJsonFolder = "<path_to_my_subset_definition>"
)
```

loading is also achieved with `getCohortDefinitionSet`

```{r eval=FALSE}
cohortDefinitionSet <- getCohortDefinitionSet(
  subsetJsonFolder = "<path_to_my_subset_definition>"
)
```

Any subset definitions should automatically be loaded and applied to the cohort definition set.

## Writing json objects

Subset definitions can be converted to JSON objects as follows:

```{r results='hide', eval=FALSE}
jsonDefinition <- subsetDef$toJSON()
```

For the purpose of writing to disk we recommend the use of `ParallelLogger` for consistency.

```{r results='hide', eval=FALSE}
# Save to a file
ParallelLogger::saveSettingsToJson(subsetDef$toList(), "subsetDefinition1.json")
```

```{r results='hide'}
options(old)
```

# Conclusion

In this tutorial, we have demonstrated how to create a subset based on a cohort using several of Cohort Generator's functionality.
