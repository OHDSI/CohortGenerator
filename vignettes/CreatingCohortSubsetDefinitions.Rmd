---
title: "Creating Cohort Subset Definitions"
author: "James P. Gilbert, Anthony G. Sena and Freddy Avila Cruz"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    toc: yes
  pdf_document:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Creating Cohort Subset Definitions}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
old <- options(width = 80)
knitr::opts_chunk$set(
  cache = FALSE,
  comment = "#>",
  error = FALSE
)
someFolder <- tempdir()
packageRoot <- tempdir()
library(CohortGenerator)
```

# Introduction

This guide aims to describe the process of cohort subsetting using `CohortGenerator`.
The purpose of Cohort subsetting operations is to refine or filter cohorts by applying standardized rules like limiting to certain events, specific time windows, combination of cohorts, etc.
As a result, new cohorts are generated to assist in specific analytics or study requirements.

To understand how to subset...
there must be some preliminary knowledge established:

## Cohort Definition Set

A cohort definition set is the starting point for any kind of work regarding the creation of subset.
A cohort definition set is what it sounds to be, a structured collection of established cohort definitions that specify rules or conditions for identifying cohorts.

Typically, a cohort definition set has the following information:

-   cohortId/ atlasId

-   cohortName

-   json

    -   The circe compliant JSON representation of the cohort definition

-   sql

    -   Description of the cohort from ATLAS

To understand more about a cohort definition set, please review **GeneratingCohorts.pdf.**

As an example, we will use a sample cohort definition set as an example for future reference.This sample cohort definition set can be found in PackageData.R in the extras folder if interested in analyzing.
It's essentially just two cohorts with the name and its id.

```{r, echo = TRUE, warning = FALSE, message = FALSE, error = FALSE,}
library(dplyr)
jsonFilePath <- system.file("testdata", "CohortsToSubset.JSON", package = "CohortGenerator")
cohortDefinitionSet <- jsonlite::fromJSON(jsonFilePath)
cohortDefinitionSet <- cohortDefinitionSet %>%
  filter(cohortId %in% c(1, 2))

cohortDefinitionSet |> 
  dplyr::select("cohortId", "cohortName") |> 
  knitr::kable()

```

## Subset Operator

A subset operator is used in the creation of a subset.
A subset operator starts off by defining or refining the logic of a cohort to meet the expectations of a new subset.
It's essentially just a rule to filter a cohort...
and we can use several methods/functions in CohortGenerator to filter a cohort:

### Demographic subset operations

This subsetting operationallows you to capture the age, race/ethnicity gender within a cohort as subgroups.
You may be interested in using this specific operation if the population is too broad and should be narrowed down to a smaller population by limiting it to demographic subgroups.

### Subsetting to other cohorts

This type of operation allows you to subset a cohort to only those subjects included in one or more other cohorts, ensuring the results focus on a shared or overlapping population.
You may want to subset a cohort if your analysis is intended to focus on individuals who are part of a shared population with overlapping characteristics, events, or exposures.

### Limit Subset

Limit subsets are designed to apply restrictions or filters to cohorts/subsets based on limit criteria.
You may want to use limit subsets if you needed to restrict or filter down a cohort based on the first or last exposure for a subject.
It may also be useful to narrow down the subset to a given time frame for a more precise analysis.
There are several ways we can do this through the various parameters provided.

## Subset Definition

A subset definition specifies what rules (subset operator) to apply to the original cohort.
It specifies which cohort to refine, and how that refinement process should look like.
The subset definition is what brings the cohort AND the subset operators to create a new subset.

# Example of Creating a Subset

Viewing our current cohort definition set that has the cohorts celcoxib and ibuprofen...
we can create a few subsets that focus on ibuprofen being the indication cohort and celcoxib being the target cohort we want to subset.
For this test, we want to create a subset/subsets that has the logic:

-   Patients exposed to Celcoxib(cohort id 1) and exposed to ibuprofen(cohort id 2)

-   Patients are between the age 20 to 50

-   The ibuprofen exposure happens during any time(before, during, or after celcoxib)

-   If there are multiple ibuprofen exposure, extract the last ibuprofen exposure

## Demographic Logic

To create a demographic subset that extracts subjects between the ages 20 - 50 years old, the subset would be defined as:

```{r}
ageCriteria <- CohortGenerator::createDemographicSubset(
  ageMin = 20,
  ageMax = 50
)
```

## Cohort Subsetting Logic

To identify subjects exposed to celcoxib who also had an exposure to ibuprofen within any time, the subset would be defined as:

```{r}
ibuprofenSubset <- CohortGenerator::createCohortSubset(
  name = "ibuprofen exposure",
  cohortIds = 2,  # Ibuprofen cohort
  cohortCombinationOperator = "any",  # Look for any Ibuprofen exposure
  negate = FALSE,  # We want to include (not exclude) participants exposed to Ibuprofen,
  windows = list(
    CohortGenerator::createSubsetCohortWindow(
        startDay = -99999,
        endDay = 99999,
        targetAnchor = "cohortStart",
        subsetAnchor = "cohortStart"
    ),
    CohortGenerator::createSubsetCohortWindow(
      startDay = -99999,
      endDay = 99999,
      targetAnchor = "cohortStart",
      subsetAnchor = "cohortEnd"
    )
  )
)
```

In this subset, we use **cohortId = 2** to extract all the subjects exposed to ibuprofen.
After that, we set the **combinationOperation = all**, meaning we are looking for exposure in both cohorts.
We then set the **negate = false** to include all subjects.

After that, we define our window, meaning that we define the time of interest we want to look for subjects with celcoxib exposed to ibuprofen.
In this case, we look for all possible time window of a subjects exposed to ibuprofen with celcoxib.
The window is defined as:

**The OBJECT must start on, after, or before the target's period**

**AND**

**the object must end on, after, or before the target's period**

To learn more about subset windowing, review Advanced Cohort Subset Tutorial vignette.

## Limit Subsetting Logic

We will create a limit subset that is focused on extracting the LAST ibuprofen exposure of a patient.

```{r}
ibuprofenLimitSubset <- CohortGenerator::createLimitSubset(
  name = "Last Ibuprofen Exposure",
  priorTime = 0,  
  followUpTime = 0,  
  limitTo = "lastEver",  # Only the first Ibuprofen exposure per patient
  calendarStartDate = as.Date("2000-01-01"),  # Start date of observation period
  calendarEndDate = as.Date("2008-12-31")  # End date of observation period
)
```

In the subset above, there is no observation period required.
The most important part is setting the limitTo parameter to lastEver, such that we can capture the last event in the patient's history.
If we wanted to know the first event in the patient's history, we would then set **limitTo = firstEver**.
If we also wanted the first event after applying a prior time, we would set**limitTo = earliestRemaining**.
The last option we have is if we wanted the last event within the observation window after applying a follow up time, we would have to set **limitTo = latestRemaining**.

# Combining all the Subset Operators

## Basic Example

Let's say we wanted to create a subset definition for patients aged between 20 to 50 that are also exposed to celcoxib.
The subset definition would be defined as:

```{r}
ageRequirementSubset <- CohortGenerator::createCohortSubsetDefinition(
  name = "Celcoxib - 20 to 50 years old ",
  definitionId = 10,
  subsetOperators = list(
    ageCriteria
  ),
  subsetCohortNameTemplate = "Celcoxib - Subjects Aged 20-50"
)
```

What this does is give the subset a unique id that it will be recognized as AND use subset operators to use the operators we want to use.
In this case, we only have to use 1 operator.
However, in the next case, we will use multiple operators.

**Advanced Example**

Let's say we wanted a more advanced subset that used the age criteria (20-50 year olds), exposed to ibuprofen within any time and if there are multiple ibuprofen exposures, extract the last ibuprofen exposure.
In order to do that, we would simply expand the number of operators being used such that we can combine an AND clause for each operator being used to produce the subset of interest.

```{r}
ibuprofenWCelcoxib <- CohortGenerator::createCohortSubsetDefinition(
  name = "Celecoxib and Ibuprofen Exposures",
  definitionId = 11,  # Unique ID for this subset
  subsetOperators = list(
    ageCriteria,
    ibuprofenSubset,
    ibuprofenLimitSubset
  ),
  subsetCohortNameTemplate = "Celcoxib with Ibuprofen Exposure - Last Exposure for Subject Aged 20 - 50"
)
```

# Adding subsets to Cohort Definition Set

Down below, we are using the addCohortSubsetDefinition function to add the new subset to the cohort definition set.
**NOTE**: we set the target id to the cohort we would specifically like to subset to.

```{r}
cohortDefinitionSet <- cohortDefinitionSet |>
  CohortGenerator::addCohortSubsetDefinition(ageRequirementSubset, targetCohortIds = c(1)) |>
  CohortGenerator::addCohortSubsetDefinition(ibuprofenWCelcoxib,targetCohortIds = c(1))
cohortDefinitionSet |> 
  dplyr::select("cohortId", "cohortName") |> 
  knitr::kable()
```

# Required Package

DuckDB is required to further demonstrate the use case of Cohort Generator for this specific vignette.
To install the `duckdb` package run:

```{r eval=FALSE}
install.packages("duckdb")
```

# Testing Data

The purpose of this test data is to demonstrate how Cohort Generator is applied by using it's functionality to create subsets based on existing cohorts.
We will begin by creating a dummy OMOP data model and populating the dummy OMOP data model with subjects and drug exposure.
The drug exposure used in the dummy OMOP data model itself will be recognized as ibuprofen exposure.
The sample data itself is found in PackageMaintenance.R found in extras folder if interested in analyzing it.

```{r, echo = TRUE, warning = FALSE, message = FALSE, error = FALSE}
databaseFile <- tempfile(fileext = ".duckdb")
duckdbConnectionDetails <- DatabaseConnector::createConnectionDetails(
  dbms = "duckdb",
  server = databaseFile
)
resultsSchema <- "main"
connection <- DatabaseConnector::connect(duckdbConnectionDetails)

DatabaseConnector::insertTable(
  connection = connection,
  databaseSchema = resultsSchema,
  tableName = "person",
  data = omopCdmPerson
)
# Insert updated data into the 'drug_exposure' table
DatabaseConnector::insertTable(
  connection = connection,
  databaseSchema = resultsSchema,
  tableName = "drug_exposure",
  data = omopCdmDrugExposure
)
```

After creating the dummy OMOP data model, we will look into generating all the cohorts into the OMOP data model.

# Generating subsets

Executing CohortGenerator, we can now include the subset operations when our cohorts are generated:

```{r, echo = TRUE, warning = FALSE, message = FALSE, error = FALSE,results= 'hide'}
cohortTableNames <- CohortGenerator::getCohortTableNames()
CohortGenerator::createCohortTables(
  connection = connection,
  cohortDatabaseSchema = "main",
  cohortTableNames = cohortTableNames
)
# ### As subsets are a big side effect we need to be clear what was generated and have good naming conventions

CohortGenerator::generateCohortSet(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTableNames = CohortGenerator::getCohortTableNames(),
  cohortDefinitionSet = cohortDefinitionSet
)


```

Cohort subset definitions can be run incrementally.
In fact, if the base cohort definition changes for any reason, any subsets will automatically be re-executed when calling `generateCohortSet`.

# Output of Dummy Test Data

In the graph below, there are 12 subjects.
Each of these subjects are exposed to celcoxib once while some of these subjects are exposed to ibuprofen, sometimes two ibuprofen exposure.The age of each subjects is also provided.
Based on this information, the subset ibuprofen with celcoxib is generated for a few selected individuals if they met the defined criteria above (celcoxib and ibuprofen, age, and extracting last ibuprofen exposure).

```{r, echo = TRUE, warning = FALSE, message = FALSE, error = FALSE, results = 'hide', fig.width = 10, fig.height = 6}
library(ggplot2)
cohorts <- DatabaseConnector::querySql(
  connection = connection,
  sql = "
    SELECT c.*, p.gender_concept_id, YEAR(c.cohort_start_date) - p.year_of_birth AS age
    FROM main.cohort c
    INNER JOIN main.person p ON c.subject_id = p.person_id
    ORDER BY c.COHORT_DEFINITION_ID, c.SUBJECT_ID, c.COHORT_START_DATE;"
)
names(cohorts) <- tolower(names(cohorts))
cohort_data <- cohorts %>%
  inner_join(cohortDefinitionSet[,c("cohortId", "cohortName")], by = c("cohort_definition_id" = "cohortId")) %>%
  mutate(cohort_legend = paste(cohort_definition_id, "-", cohortName)) %>%
  mutate(gender = ifelse(gender_concept_id == 8532, "Female", "Male"), 
         facet_label = paste("Subject:", subject_id, "- Gender:", gender)) 

# Order factor levels for facets by subject_id
cohort_data$facet_label <- factor(cohort_data$facet_label, 
                                  levels = unique(cohort_data$facet_label[order(cohort_data$subject_id)]))

# Order factor levels for legend by cohort_definition_id
cohort_data$cohort_legend <- factor(cohort_data$cohort_legend, 
                                    levels = unique(cohort_data$cohort_legend[order(cohort_data$cohort_definition_id)]))

# Create the plot with annotations for age when cohort_definition_id == 1
ggplot(cohort_data, aes(x = cohort_start_date, xend = cohort_end_date, 
                        y = as.factor(cohort_definition_id), 
                        group = interaction(cohort_definition_id, subject_id), 
                        color = cohort_legend)) +
  geom_segment(aes(xend = cohort_end_date, yend = as.factor(cohort_definition_id)), size = 2) +  
  geom_point(aes(x = cohort_start_date, y = as.factor(cohort_definition_id)), size = 4, shape = 21, fill = "black") +  
  geom_text(data = cohort_data[cohort_data$cohort_definition_id == 1, ], 
            aes(label = age, 
                x = as.Date((as.numeric(cohort_start_date) + as.numeric(cohort_end_date)) / 2, origin = "1970-01-01"),  
                y = as.factor(cohort_definition_id)), 
            vjust = -0.5, size = 4, color = "black") +  
  labs(title = "Cohort Duration by Cohort Definition ID Faceted by Subject ID and Gender",
       x = "Date",
       y = "Cohort Definition ID",
       color = "Cohort Definition") +
  scale_x_date(limits = as.Date(c("2002-01-01", "2004-06-31")), date_breaks = "1 year", date_labels = "%Y") +  
  scale_color_brewer(palette = "Paired") +  
  guides(color = guide_legend(nrow = 2, byrow = TRUE)) +  # Wrap legend into 2 rows
  theme_minimal() +
  theme(
    legend.position = "bottom",  # Position the legend at the bottom
    legend.box = "vertical",     # Stack the legend vertically if it overflows
    legend.text = element_text(size = 10),  # Adjust font size for readability
    legend.spacing.x = unit(0.5, 'cm'),     # Add spacing between legend items
    plot.margin = margin(10, 10, 50, 10)   # Increase bottom margin to accommodate the legend
  ) +
  facet_wrap(~ facet_label)  # Correct facet wrapping

```

# Saving and loading subset definitions

## Saving to packages/directories

Saving applied subsets can automatically be added to a project using `saveCohortDefinitionSet`

```{r eval=FALSE}
saveCohortDefinitionSet(cohortDefinitionSet,
  subsetJsonFolder = "<path_to_my_subset_definition>"
)
```

loading is also achieved with `getCohortDefinitionSet`

```{r eval=FALSE}
cohortDefinitionSet <- getCohortDefinitionSet(
  subsetJsonFolder = "<path_to_my_subset_definition>"
)
```

Any subset definitions should automatically be loaded and applied to the cohort definition set.

## Writing json objects

Subset definitions can be converted to JSON objects as follows:

```{r results='hide', eval=FALSE}
jsonDefinition <- subsetDef$toJSON()
```

For the purpose of writing to disk we recommend the use of `ParallelLogger` for consistency.

```{r results='hide', eval=FALSE}
# Save to a file
ParallelLogger::saveSettingsToJson(subsetDef$toList(), "subsetDefinition1.json")
```

```{r results='hide'}
options(old)
```

# Conclusion

In this tutorial, we have demonstrated how to create a subset based on a cohort using several of Cohort Generator's functionality.
