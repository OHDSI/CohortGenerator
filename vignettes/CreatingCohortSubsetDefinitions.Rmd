---
title: "Creating Cohort Subset Definitions"
author: "James P. Gilbert"
date: "`r Sys.Date()`"
output:
pdf_document:
toc: yes
html_document:
number_sections: yes
toc: yes
vignette: >
%\VignetteIndexEntry{Generating Cohorts}
%\VignetteEncoding{UTF-8}
%\VignetteEngine{knitr::rmarkdown}
editor_options:
chunk_output_type: console
---

```{r setup, include=FALSE}
options(width = 80)
knitr::opts_chunk$set(
  cache = FALSE,
  comment = "#>",
  error = FALSE)
someFolder <- tempdir()
packageRoot <- tempdir()
baseUrl <- "https://api.ohdsi.org/WebAPI"
```
# Creating Cohort subset definition
First get a Cohort definition set:
```{r results='hide', error=FALSE, warning=FALSE, message=FALSE}
library(CohortGenerator)
# A list of cohort IDs for use in this vignette
cohortIds <- c(1778211, 1778212, 1778213)
# Get the SQL/JSON for the cohorts
cohortDefinitionSet <- ROhdsiWebApi::exportCohortDefinitionSet(baseUrl = baseUrl,
                                                               cohortIds = cohortIds)
```

A definition can include different subset operations - these are applied strictly in order:

```{r results='hide', error=FALSE, warning=FALSE, message=FALSE}
# TODO: Need more description of how to use the window classes
# to define the intersection between a target & subset cohort
targetStartEndpoint <- Endpoint$new()
targetStartEndpoint$coeff <- -1

targetEndEndpoint <- Endpoint$new()
targetEndEndpoint$coeff <- -1

targetCohortWindow <- Window$new()
targetCohortWindow$useIndexEnd <- FALSE
targetCohortWindow$useEventEnd <- FALSE
targetCohortWindow$start <- targetStartEndpoint
targetCohortWindow$end <- targetEndEndpoint

# This is a nonsense example for now
subsetCohortWindow <- Window$new()
subsetCohortWindow$useIndexEnd <- FALSE
subsetCohortWindow$useEventEnd <- FALSE
subsetCohortWindow$start <- targetStartEndpoint
subsetCohortWindow$end <- targetEndEndpoint

subsetOperations <- list(
  # here we are saying 'first subset to only those patients in cohort 1778213'
  createCohortSubset(id = 1001,
                     name = "Cohort Subset",
                     cohortIds = 1778213,
                     cohortCombinationOperator = "any",
                     negate = FALSE,
                     targetCohortWindow = targetCohortWindow,
                     subsetCohortWindow = subsetCohortWindow),
  
  # Next, subset to only those with 365 days of prior observation
  createLimitSubset(id = 1002,
                    name = "Observation of at least 365 days prior",
                    priorTime = 365,
                    followUpTime = 0,
                    limitTo = "firstEver")
)
```
We then need to capture these definitions in a definition object

```{r results='hide', error=FALSE, warning=FALSE, message=FALSE}
subsetDef <- createCohortSubsetDefinition(name = "365 days prior",
                                          definitionId = 1,
                                          targetOutcomePairs = list(c(1778211, 1778211001), c(1778212, 1778212001)),
                                          subsets = subsetOperations)
```

Next we create a similar definition that also subsets the specified cohorts to require patients with specific
demographic criteria:

```{r results='hide', error=FALSE, warning=FALSE, message=FALSE}
subsetOperations2 <- subsetOperations

# subset to those between aged 18 an 64
subsetOperations2[[3]] <- createDemographicSubset(id = 1003,
                                                  name = "18 - 65",
                                                  ageMin = 18,
                                                  ageMax = 64)

subsetDef2 <- createCohortSubsetDefinition(name = "365 days prior, aged 18 - 64",
                                           definitionId = 2,
                                           # NOTE: The output ids should not clash with any that already exist
                                           targetOutcomePairs = list(c(1778211, 1778211002), c(1778212, 1778212002)),
                                           subsets = subsetOperations2)

```
### Generating subsets
The following is not yet implemented but serves as a straw man for how we would like this to work.

Executing CohortGenerator, we can now include the subset operations when our cohorts are generated:

```{r results='hide', error=FALSE, warning=FALSE, message=FALSE, eval=FALSE}

### As subsets are a big side effect we need to be clear what was generated and have good naming conventions
generatedCohortDefinitionSetSummary <- generateCohortSet(connectionDetails = connectionDetails,
                                                         cdmDatabaseSchema = cdmDatabaseSchema,
                                                         cohortDatabaseSchema = cohortDatabaseSchema,
                                                         cohortTableNames = "my_cohort",
                                                         cohortDefinitionSet = cohortDefinitionSet,
                                                         subsetDefinitions = list(subsetDef, subsetDef2),
                                                         incremental = TRUE,
                                                         incrementalFolder = file.path(someFolder, "RecordKeeping"))
```
The object ```generatedCohortDefinitionSetSummary``` contains the base set of cohorts as well as the named set of these subset cohorts,
the names will be automatically generated based on the base id and then the subset operations that are applied.

<!-- ### Saving the JSON -->

<!-- ```{r eval=FALSE} -->
<!-- subsetDefinitions <- list(subsetDef, subsetDef2) -->

<!-- # Does not work due to use of R6 classes: -->
<!-- ParallelLogger::saveSettingsToJson(object = subsetDefinitions, fileName = "subset.json") -->

<!-- # TODO: We need to implement a way to seralize the lis of subset definitions -->
<!-- ``` -->
